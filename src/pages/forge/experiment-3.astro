---
import Layout from "../../layouts/Layout.astro";
import Navbar from "../../layouts/Navigation.astro";
import Footer from "../../layouts/Footer.astro";
---

<Layout title="Advanced Shaders - The Forge" description="Custom materials and effects experiment">
  <Navbar>
    <div class="min-h-screen bg-secondary">
      <!-- Header -->
      <div class="pt-16 pb-8 px-4 sm:px-6 lg:px-8">
        <div class="max-w-7xl mx-auto">
          <div class="flex items-center justify-between mb-8">
            <div>
              <a href="/forge" class="inline-flex items-center text-primary/60 hover:text-primary transition-colors font-mono text-sm mb-4">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
                </svg>
                Back to Forge
              </a>
              <h1 class="text-3xl sm:text-4xl font-mono text-primary mb-2">Advanced Shaders</h1>
              <p class="text-primary/70 font-mono">Custom materials and effects</p>
            </div>
            <div class="hidden sm:flex items-center space-x-4">
              <button id="play-pause" class="px-4 py-2 border border-primary/20 text-primary/80 hover:bg-primary/10 transition-colors font-mono text-sm">
                Pause
              </button>
              <button id="reset-camera" class="px-4 py-2 border border-primary/20 text-primary/80 hover:bg-primary/10 transition-colors font-mono text-sm">
                Reset View
              </button>
            </div>
          </div>
        </div>
      </div>

      <!-- ThreeJS Container -->
      <div class="px-4 sm:px-6 lg:px-8">
        <div class="max-w-7xl mx-auto">
          <div id="threejs-container" class="w-full h-96 border border-primary/20 rounded-lg overflow-hidden bg-black/50">
            <div class="loading-container">
              <div class="loading-spinner"></div>
              <p class="text-primary/60 font-mono text-sm mt-4">Loading shader experiment...</p>
            </div>
          </div>
          
          <!-- Controls Info -->
          <div class="mt-6 p-4 border border-primary/10 rounded-lg bg-primary/5">
            <h3 class="text-lg font-mono text-primary mb-2">Shader Effects</h3>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 text-sm font-mono text-primary/70">
              <div>
                <p><strong>Mouse:</strong> Rotate camera around the scene</p>
                <p><strong>Scroll:</strong> Zoom in/out</p>
              </div>
              <div>
                <p><strong>Space:</strong> Toggle animation</p>
                <p><strong>R:</strong> Reset camera position</p>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </Navbar>
  <Footer />
</Layout>

<script>
  import * as THREE from "three";
  import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";

  // Scene variables
  let scene: THREE.Scene;
  let camera: THREE.PerspectiveCamera;
  let renderer: THREE.WebGLRenderer;
  let cube: THREE.Mesh;
  let controls: OrbitControls;
  let animationId: number;
  let isAnimating = true;
  let time = 0;

  // Custom shader material
  const vertexShader = `
    varying vec2 vUv;
    varying vec3 vPosition;
    varying vec3 vNormal;
    
    void main() {
      vUv = uv;
      vPosition = position;
      vNormal = normal;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `;

  const fragmentShader = `
    uniform float time;
    uniform vec3 color1;
    uniform vec3 color2;
    uniform vec3 color3;
    
    varying vec2 vUv;
    varying vec3 vPosition;
    varying vec3 vNormal;
    
    void main() {
      // Create animated gradient based on UV coordinates and time
      vec2 uv = vUv;
      
      // Add some noise and distortion
      float noise = sin(uv.x * 10.0 + time) * sin(uv.y * 10.0 + time) * 0.1;
      uv += noise;
      
      // Create gradient
      vec3 color = mix(color1, color2, uv.x);
      color = mix(color, color3, uv.y);
      
      // Add some metallic effect
      float fresnel = 1.0 - dot(vNormal, vec3(0.0, 0.0, 1.0));
      color += fresnel * 0.3;
      
      // Add some pulsing effect
      float pulse = sin(time * 2.0) * 0.1 + 0.9;
      color *= pulse;
      
      gl_FragColor = vec4(color, 1.0);
    }
  `;

  // Initialize ThreeJS scene
  function initThreeJS() {
    const container = document.getElementById('threejs-container');
    if (!container) return;

    // Clear loading content
    container.innerHTML = '';

    // Scene setup
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);

    // Camera setup
    camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
    camera.position.set(3, 3, 3);

    // Renderer setup
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    container.appendChild(renderer.domElement);

    // Create cube with custom shader
    const geometry = new THREE.BoxGeometry(1, 1, 1);
    const material = new THREE.ShaderMaterial({
      vertexShader,
      fragmentShader,
      uniforms: {
        time: { value: 0 },
        color1: { value: new THREE.Color(0xff6b6b) },
        color2: { value: new THREE.Color(0x4ecdc4) },
        color3: { value: new THREE.Color(0x45b7d1) }
      }
    });
    
    cube = new THREE.Mesh(geometry, material);
    cube.castShadow = true;
    cube.receiveShadow = true;
    scene.add(cube);

    // Add wireframe cube for extra visual interest
    const wireframeGeometry = new THREE.BoxGeometry(1.1, 1.1, 1.1);
    const wireframeMaterial = new THREE.MeshBasicMaterial({ 
      color: 0xffffff, 
      wireframe: true,
      transparent: true,
      opacity: 0.3
    });
    const wireframeCube = new THREE.Mesh(wireframeGeometry, wireframeMaterial);
    scene.add(wireframeCube);

    // Lighting setup
    const ambientLight = new THREE.AmbientLight(0x404040, 0.3);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(5, 5, 5);
    directionalLight.castShadow = true;
    scene.add(directionalLight);

    // Add some colored lights
    const light1 = new THREE.PointLight(0xff6b6b, 0.5, 10);
    light1.position.set(2, 2, 2);
    scene.add(light1);

    const light2 = new THREE.PointLight(0x4ecdc4, 0.5, 10);
    light2.position.set(-2, -2, 2);
    scene.add(light2);

    // Controls setup
    controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.enableZoom = true;
    controls.enablePan = false;

    // Start animation loop
    animate();

    // Event listeners
    setupEventListeners();
  }

  // Animation loop
  function animate() {
    animationId = requestAnimationFrame(animate);

    time += 0.016; // ~60fps

    if (isAnimating && cube) {
      cube.rotation.x += 0.005;
      cube.rotation.y += 0.01;
      
      // Update shader time uniform
      if (cube.material instanceof THREE.ShaderMaterial) {
        cube.material.uniforms.time.value = time;
      }
    }

    if (controls) {
      controls.update();
    }

    if (renderer && scene && camera) {
      renderer.render(scene, camera);
    }
  }

  // Setup event listeners
  function setupEventListeners() {
    // Play/Pause button
    const playPauseBtn = document.getElementById('play-pause');
    if (playPauseBtn) {
      playPauseBtn.addEventListener('click', () => {
        isAnimating = !isAnimating;
        playPauseBtn.textContent = isAnimating ? 'Pause' : 'Play';
      });
    }

    // Reset camera button
    const resetBtn = document.getElementById('reset-camera');
    if (resetBtn) {
      resetBtn.addEventListener('click', () => {
        if (camera && controls) {
          camera.position.set(3, 3, 3);
          controls.target.set(0, 0, 0);
          controls.update();
        }
      });
    }

    // Keyboard controls
    document.addEventListener('keydown', (event) => {
      switch(event.code) {
        case 'Space':
          event.preventDefault();
          isAnimating = !isAnimating;
          if (playPauseBtn) {
            playPauseBtn.textContent = isAnimating ? 'Pause' : 'Play';
          }
          break;
        case 'KeyR':
          if (camera && controls) {
            camera.position.set(3, 3, 3);
            controls.target.set(0, 0, 0);
            controls.update();
          }
          break;
      }
    });

    // Window resize
    window.addEventListener('resize', () => {
      const container = document.getElementById('threejs-container');
      if (container && camera && renderer) {
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
      }
    });
  }

  // Initialize when DOM is loaded
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initThreeJS);
  } else {
    initThreeJS();
  }
</script>

<style>
  .loading-container {
    @apply flex flex-col items-center justify-center h-full;
  }

  .loading-spinner {
    @apply w-8 h-8 border-2 border-primary/20 border-t-primary rounded-full animate-spin;
  }

  #threejs-container {
    position: relative;
  }

  #threejs-container canvas {
    display: block;
  }
</style>
