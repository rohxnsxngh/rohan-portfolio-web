<!-- ---
import Layout from "../../layouts/Layout.astro";
import Navbar from "../../layouts/Navigation.astro";
import Footer from "../../layouts/Footer.astro";
---

<Layout title="Particle Systems - The Forge" description="Dynamic particles and physics experiment">
  <Navbar>
    <div class="min-h-screen bg-secondary">
      <!-- Header -->
      <div class="pt-16 pb-8 px-4 sm:px-6 lg:px-8">
        <div class="max-w-7xl mx-auto">
          <div class="flex items-center justify-between mb-8">
            <div>
              <a href="/forge" class="inline-flex items-center text-primary/60 hover:text-primary transition-colors font-mono text-sm mb-4">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
                </svg>
                Back to Forge
              </a>
              <h1 class="text-3xl sm:text-4xl font-mono text-primary mb-2">Particle Systems</h1>
              <p class="text-primary/70 font-mono">Dynamic particles and physics</p>
            </div>
            <div class="hidden sm:flex items-center space-x-4">
              <button id="play-pause" class="px-4 py-2 border border-primary/20 text-primary/80 hover:bg-primary/10 transition-colors font-mono text-sm">
                Pause
              </button>
              <button id="reset-particles" class="px-4 py-2 border border-primary/20 text-primary/80 hover:bg-primary/10 transition-colors font-mono text-sm">
                Reset Particles
              </button>
            </div>
          </div>
        </div>
      </div>

      <!-- ThreeJS Container -->
      <div class="px-4 sm:px-6 lg:px-8">
        <div class="max-w-7xl mx-auto">
          <div id="threejs-container" class="w-full h-96 border border-primary/20 rounded-lg overflow-hidden bg-black/50">
            <div class="loading-container">
              <div class="loading-spinner"></div>
              <p class="text-primary/60 font-mono text-sm mt-4">Loading particle system...</p>
            </div>
          </div>
          
          <!-- Controls Info -->
          <div class="mt-6 p-4 border border-primary/10 rounded-lg bg-primary/5">
            <h3 class="text-lg font-mono text-primary mb-2">Particle Controls</h3>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 text-sm font-mono text-primary/70">
              <div>
                <p><strong>Mouse:</strong> Rotate camera around the scene</p>
                <p><strong>Scroll:</strong> Zoom in/out</p>
              </div>
              <div>
                <p><strong>Space:</strong> Toggle animation</p>
                <p><strong>R:</strong> Reset particles</p>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </Navbar>
  <Footer />
</Layout>

<script>
  import * as THREE from "three";
  import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";

  // Scene variables
  let scene: THREE.Scene;
  let camera: THREE.PerspectiveCamera;
  let renderer: THREE.WebGLRenderer;
  let particleSystem: THREE.Points;
  let controls: OrbitControls;
  let animationId: number;
  let isAnimating = true;
  let time = 0;
  let particles: any[] = [];

  // Initialize ThreeJS scene
  function initThreeJS() {
    const container = document.getElementById('threejs-container');
    if (!container) return;

    // Clear loading content
    container.innerHTML = '';

    // Scene setup
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);

    // Camera setup
    camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
    camera.position.set(0, 0, 10);

    // Renderer setup
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.setPixelRatio(window.devicePixelRatio);

    container.appendChild(renderer.domElement);

    // Create particle system
    createParticleSystem();

    // Add a central cube for reference
    const cubeGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
    const cubeMaterial = new THREE.MeshBasicMaterial({ 
      color: 0xffffff,
      wireframe: true,
      transparent: true,
      opacity: 0.3
    });
    const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
    scene.add(cube);

    // Lighting setup
    const ambientLight = new THREE.AmbientLight(0x404040, 0.2);
    scene.add(ambientLight);

    // Controls setup
    controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.enableZoom = true;
    controls.enablePan = false;

    // Start animation loop
    animate();

    // Event listeners
    setupEventListeners();
  }

  // Create particle system
  function createParticleSystem() {
    const particleCount = 1000;
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(particleCount * 3);
    const colors = new Float32Array(particleCount * 3);
    const sizes = new Float32Array(particleCount);

    // Initialize particles
    for (let i = 0; i < particleCount; i++) {
      const i3 = i * 3;
      
      // Random positions in a sphere
      const radius = Math.random() * 5 + 1;
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.acos(2 * Math.random() - 1);
      
      positions[i3] = radius * Math.sin(phi) * Math.cos(theta);
      positions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
      positions[i3 + 2] = radius * Math.cos(phi);
      
      // Random colors
      const color = new THREE.Color();
      color.setHSL(Math.random() * 0.1 + 0.5, 0.7, 0.6);
      colors[i3] = color.r;
      colors[i3 + 1] = color.g;
      colors[i3 + 2] = color.b;
      
      // Random sizes
      sizes[i] = Math.random() * 2 + 1;
      
      // Store particle data for animation
      particles.push({
        originalX: positions[i3],
        originalY: positions[i3 + 1],
        originalZ: positions[i3 + 2],
        velocity: {
          x: (Math.random() - 0.5) * 0.02,
          y: (Math.random() - 0.5) * 0.02,
          z: (Math.random() - 0.5) * 0.02
        },
        phase: Math.random() * Math.PI * 2
      });
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

    // Create shader material for particles
    const material = new THREE.ShaderMaterial({
      uniforms: {
        time: { value: 0 },
        pointTexture: { value: createParticleTexture() }
      },
      vertexShader: `
        attribute float size;
        attribute vec3 color;
        uniform float time;
        varying vec3 vColor;
        
        void main() {
          vColor = color;
          vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
          gl_PointSize = size * (300.0 / -mvPosition.z);
          gl_Position = projectionMatrix * mvPosition;
        }
      `,
      fragmentShader: `
        uniform sampler2D pointTexture;
        varying vec3 vColor;
        
        void main() {
          gl_FragColor = vec4(vColor, 1.0);
          gl_FragColor = gl_FragColor * texture2D(pointTexture, gl_PointCoord);
        }
      `,
      blending: THREE.AdditiveBlending,
      depthTest: false,
      transparent: true,
      vertexColors: true
    });

    particleSystem = new THREE.Points(geometry, material);
    scene.add(particleSystem);
  }

  // Create particle texture
  function createParticleTexture() {
    const canvas = document.createElement('canvas');
    canvas.width = 32;
    canvas.height = 32;
    const context = canvas.getContext('2d');
    
    if (context) {
      const gradient = context.createRadialGradient(16, 16, 0, 16, 16, 16);
      gradient.addColorStop(0, 'rgba(255,255,255,1)');
      gradient.addColorStop(0.2, 'rgba(255,255,255,0.8)');
      gradient.addColorStop(0.4, 'rgba(255,255,255,0.4)');
      gradient.addColorStop(1, 'rgba(255,255,255,0)');
      
      context.fillStyle = gradient;
      context.fillRect(0, 0, 32, 32);
    }
    
    const texture = new THREE.CanvasTexture(canvas);
    return texture;
  }

  // Animation loop
  function animate() {
    animationId = requestAnimationFrame(animate);

    time += 0.016;

    if (isAnimating && particleSystem) {
      const positions = particleSystem.geometry.attributes.position.array;
      
      for (let i = 0; i < particles.length; i++) {
        const i3 = i * 3;
        const particle = particles[i];
        
        // Update position with wave motion
        positions[i3] = particle.originalX + Math.sin(time + particle.phase) * 0.5;
        positions[i3 + 1] = particle.originalY + Math.cos(time + particle.phase) * 0.5;
        positions[i3 + 2] = particle.originalZ + Math.sin(time * 0.5 + particle.phase) * 0.3;
        
        // Add some drift
        positions[i3] += particle.velocity.x;
        positions[i3 + 1] += particle.velocity.y;
        positions[i3 + 2] += particle.velocity.z;
        
        // Reset if too far
        const distance = Math.sqrt(positions[i3] ** 2 + positions[i3 + 1] ** 2 + positions[i3 + 2] ** 2);
        if (distance > 8) {
          positions[i3] = particle.originalX;
          positions[i3 + 1] = particle.originalY;
          positions[i3 + 2] = particle.originalZ;
        }
      }
      
      particleSystem.geometry.attributes.position.needsUpdate = true;
      
      // Rotate the entire particle system
      particleSystem.rotation.y += 0.001;
    }

    if (controls) {
      controls.update();
    }

    if (renderer && scene && camera) {
      renderer.render(scene, camera);
    }
  }

  // Reset particles
  function resetParticles() {
    if (particleSystem) {
      const positions = particleSystem.geometry.attributes.position.array;
      
      for (let i = 0; i < particles.length; i++) {
        const i3 = i * 3;
        const particle = particles[i];
        
        positions[i3] = particle.originalX;
        positions[i3 + 1] = particle.originalY;
        positions[i3 + 2] = particle.originalZ;
      }
      
      particleSystem.geometry.attributes.position.needsUpdate = true;
    }
  }

  // Setup event listeners
  function setupEventListeners() {
    // Play/Pause button
    const playPauseBtn = document.getElementById('play-pause');
    if (playPauseBtn) {
      playPauseBtn.addEventListener('click', () => {
        isAnimating = !isAnimating;
        playPauseBtn.textContent = isAnimating ? 'Pause' : 'Play';
      });
    }

    // Reset particles button
    const resetBtn = document.getElementById('reset-particles');
    if (resetBtn) {
      resetBtn.addEventListener('click', resetParticles);
    }

    // Keyboard controls
    document.addEventListener('keydown', (event) => {
      switch(event.code) {
        case 'Space':
          event.preventDefault();
          isAnimating = !isAnimating;
          if (playPauseBtn) {
            playPauseBtn.textContent = isAnimating ? 'Pause' : 'Play';
          }
          break;
        case 'KeyR':
          resetParticles();
          break;
      }
    });

    // Window resize
    window.addEventListener('resize', () => {
      const container = document.getElementById('threejs-container');
      if (container && camera && renderer) {
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
      }
    });
  }

  // Initialize when DOM is loaded
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initThreeJS);
  } else {
    initThreeJS();
  }
</script>

<style>
  .loading-container {
    @apply flex flex-col items-center justify-center h-full;
  }

  .loading-spinner {
    @apply w-8 h-8 border-2 border-primary/20 border-t-primary rounded-full animate-spin;
  }

  #threejs-container {
    position: relative;
  }

  #threejs-container canvas {
    display: block;
  }
</style> -->
