---
import Layout from "../../layouts/Layout.astro";
import Navbar from "../../layouts/Navigation.astro";
import Footer from "../../layouts/Footer.astro";
---

<Layout title="Instanced Cube Grid - The Forge" description="Dynamic 3D grid with noise-based animation and procedural colors">
  <Navbar>
    <div class="min-h-screen bg-secondary">
      <!-- Header -->
      <div class="pt-16 pb-8 px-4 sm:px-6 lg:px-8">
        <div class="max-w-7xl mx-auto">
          <div class="flex items-center justify-between mb-8">
            <div>
              <a href="/forge" class="inline-flex items-center text-primary/60 hover:text-primary transition-colors font-mono text-sm mb-4">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
                </svg>
                Back to Forge
              </a>
              <h1 class="text-3xl sm:text-4xl font-mono text-primary mb-2">Instanced Cube Grid</h1>
              <p class="text-primary/70 font-mono">Dynamic 3D grid with noise-based animation</p>
            </div>
            <div class="hidden sm:flex items-center space-x-4">
              <button id="play-pause" class="px-4 py-2 border border-primary/20 text-primary/80 hover:bg-primary/10 transition-colors font-mono text-sm">
                Pause
              </button>
              <button id="reset-camera" class="px-4 py-2 border border-primary/20 text-primary/80 hover:bg-primary/10 transition-colors font-mono text-sm">
                Reset View
              </button>
              <button id="wireframe-toggle" class="px-4 py-2 border border-primary/20 text-primary/80 hover:bg-primary/10 transition-colors font-mono text-sm">
                Wireframe
              </button>
            </div>
          </div>
        </div>
      </div>

      <!-- ThreeJS Container -->
      <div class="px-4 sm:px-6 lg:px-8">
        <div class="max-w-7xl mx-auto">
          <div id="threejs-container" class="w-full h-[600px] border border-primary/20 rounded-lg overflow-hidden bg-black/50">
            <div class="loading-container">
              <div class="loading-spinner"></div>
              <p class="text-primary/60 font-mono text-sm mt-4">Loading instanced mesh scene...</p>
            </div>
          </div>
          
          <!-- Controls Info -->
          <div class="mt-6 p-4 border border-primary/10 rounded-lg bg-primary/5">
            <h3 class="text-lg font-mono text-primary mb-2">Controls & Features</h3>
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 text-sm font-mono text-primary/70">
              <div>
                <p><strong>Mouse:</strong> Rotate camera</p>
                <p><strong>Scroll:</strong> Zoom in/out</p>
                <p><strong>Space:</strong> Toggle animation</p>
              </div>
              <div>
                <p><strong>R:</strong> Reset camera</p>
                <p><strong>W:</strong> Toggle wireframe</p>
                <p><strong>Performance:</strong> 8000 instances</p>
              </div>
              <div>
                <p><strong>Features:</strong> Perlin noise scaling</p>
                <p><strong>Colors:</strong> Procedural HSL</p>
                <p><strong>Rendering:</strong> Hardware instancing</p>
              </div>
            </div>
          </div>

          <!-- Technical Details -->
          <div class="mt-4 p-4 border border-primary/10 rounded-lg bg-primary/5">
            <h3 class="text-lg font-mono text-primary mb-2">Technical Implementation</h3>
            <p class="text-sm font-mono text-primary/70 leading-relaxed">
              This demo showcases hardware instancing with THREE.InstancedMesh, rendering 8000 individual cubes efficiently. 
              Each cube's scale is modulated by 3D Perlin noise, creating organic wave-like motion through the grid. 
              Colors are procedurally generated using HSL color space, creating a dynamic rainbow effect that follows the noise patterns.
              The entire grid rotates slowly while individual cubes pulse and change color based on their noise values.
            </p>
          </div>
        </div>
      </div>
    </div>
  </Navbar>
  <Footer />
</Layout>

<script>
  import * as THREE from "three";
  import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";

  // Simple Perlin noise implementation (simplified version)
  class SimpleNoise {
    constructor() {
      this.perm = this.generatePermutation();
    }

    generatePermutation() {
      const p = [];
      for (let i = 0; i < 256; i++) p[i] = i;
      
      // Fisher-Yates shuffle
      for (let i = 255; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [p[i], p[j]] = [p[j], p[i]];
      }
      
      // Duplicate the array
      return [...p, ...p];
    }

    fade(t) {
      return t * t * t * (t * (t * 6 - 15) + 10);
    }

    lerp(t, a, b) {
      return a + t * (b - a);
    }

    grad(hash, x, y, z) {
      const h = hash & 15;
      const u = h < 8 ? x : y;
      const v = h < 4 ? y : h === 12 || h === 14 ? x : z;
      return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
    }

    noise(x, y, z) {
      const X = Math.floor(x) & 255;
      const Y = Math.floor(y) & 255;
      const Z = Math.floor(z) & 255;

      x -= Math.floor(x);
      y -= Math.floor(y);
      z -= Math.floor(z);

      const u = this.fade(x);
      const v = this.fade(y);
      const w = this.fade(z);

      const A = this.perm[X] + Y;
      const AA = this.perm[A] + Z;
      const AB = this.perm[A + 1] + Z;
      const B = this.perm[X + 1] + Y;
      const BA = this.perm[B] + Z;
      const BB = this.perm[B + 1] + Z;

      return this.lerp(w,
        this.lerp(v,
          this.lerp(u, this.grad(this.perm[AA], x, y, z),
                      this.grad(this.perm[BA], x - 1, y, z)),
          this.lerp(u, this.grad(this.perm[AB], x, y - 1, z),
                      this.grad(this.perm[BB], x - 1, y - 1, z))),
        this.lerp(v,
          this.lerp(u, this.grad(this.perm[AA + 1], x, y, z - 1),
                      this.grad(this.perm[BA + 1], x - 1, y, z - 1)),
          this.lerp(u, this.grad(this.perm[AB + 1], x, y - 1, z - 1),
                      this.grad(this.perm[BB + 1], x - 1, y - 1, z - 1))));
    }
  }

  // Scene variables
  let scene: THREE.Scene;
  let camera: THREE.PerspectiveCamera;
  let renderer: THREE.WebGLRenderer;
  let controls: OrbitControls;
  let mesh: THREE.InstancedMesh;
  let animationId: number;
  let isAnimating = true;
  let wireframeMode = false;

  // Animation variables
  const amount = 20; // 20x20x20 = 8000 cubes
  const count = Math.pow(amount, 3);
  const dummy = new THREE.Object3D();
  const noise = new SimpleNoise();
  const color = new THREE.Color();

  // Noise parameters
  const noisseAmplitude = 0.1;
  const noiseScale = 3;
  const offset = (amount - 1) / 2;

  // Initialize ThreeJS scene
  function initThreeJS() {
    const container = document.getElementById('threejs-container');
    if (!container) return;

    // Clear loading content
    container.innerHTML = '';

    // Scene setup
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);

    // Camera setup
    camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 100);
    camera.position.z = amount * 1.8;

    // Renderer setup
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.setPixelRatio(window.devicePixelRatio);

    container.appendChild(renderer.domElement);

    // Create instanced mesh
    const size = 0.5;
    const geometry = new THREE.BoxGeometry(size, size, size);
    const material = new THREE.MeshBasicMaterial({ 
      color: 0xffffff,
      transparent: true,
      opacity: 0.8
    });

    mesh = new THREE.InstancedMesh(geometry, material, count);
    mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
    mesh.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(count * 3), 3);
    scene.add(mesh);

    // Controls setup
    controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.enableZoom = true;
    controls.enablePan = true;

    // Start animation loop
    animate();

    // Event listeners
    setupEventListeners();
  }

  // Update cube instances
  function updateInstances(time: number) {
    let i = 0;
    
    for (let x = 0; x < amount; x++) {
      for (let y = 0; y < amount; y++) {
        for (let z = 0; z < amount; z++) {
          // Position
          dummy.position.set(offset - x, offset - y, offset - z);
          
          // Noise-based scaling
          const noiseValue = noise.noise(
            time + x * noisseAmplitude, 
            time + y * noisseAmplitude, 
            time + z * noisseAmplitude
          ) * noiseScale;
          
          const scale = Math.max(0.1, 1 + noiseValue);
          dummy.scale.setScalar(scale);
          
          // Procedural color based on noise
          const hue = 0.6 + noiseValue * 0.3; // Cycle through colors
          const saturation = 1.0;
          const lightness = 0.3 + Math.abs(noiseValue) * 0.4;
          
          color.setHSL(hue, saturation, lightness);
          mesh.setColorAt(i, color);
          
          // Optional rotation (uncomment for extra animation)
          // dummy.rotation.y = Math.sin(x * 0.25 + time) + Math.sin(y * 0.25 + time) + Math.sin(z * 0.25 + time);
          // dummy.rotation.z = dummy.rotation.y * 2;
          
          dummy.updateMatrix();
          mesh.setMatrixAt(i, dummy.matrix);
          
          i++;
        }
      }
    }
    
    mesh.instanceMatrix.needsUpdate = true;
    mesh.instanceColor.needsUpdate = true;
  }

  // Animation loop
  function animate() {
    animationId = requestAnimationFrame(animate);

    if (isAnimating) {
      const time = performance.now() * 0.0003;
      
      // Rotate the entire mesh slowly
      mesh.rotation.x = Math.sin(time * 0.25);
      mesh.rotation.y = Math.sin(time * 0.2);
      
      // Update individual instances
      updateInstances(time);
    }

    if (controls) {
      controls.update();
    }

    if (renderer && scene && camera) {
      renderer.render(scene, camera);
    }
  }

  // Setup event listeners
  function setupEventListeners() {
    // Play/Pause button
    const playPauseBtn = document.getElementById('play-pause');
    if (playPauseBtn) {
      playPauseBtn.addEventListener('click', () => {
        isAnimating = !isAnimating;
        playPauseBtn.textContent = isAnimating ? 'Pause' : 'Play';
      });
    }

    // Reset camera button
    const resetBtn = document.getElementById('reset-camera');
    if (resetBtn) {
      resetBtn.addEventListener('click', () => {
        if (camera && controls) {
          camera.position.set(0, 0, amount * 1.8);
          controls.target.set(0, 0, 0);
          controls.update();
        }
      });
    }

    // Wireframe toggle button
    const wireframeBtn = document.getElementById('wireframe-toggle');
    if (wireframeBtn) {
      wireframeBtn.addEventListener('click', () => {
        wireframeMode = !wireframeMode;
        if (mesh && mesh.material) {
          (mesh.material as THREE.MeshBasicMaterial).wireframe = wireframeMode;
        }
        wireframeBtn.textContent = wireframeMode ? 'Solid' : 'Wireframe';
      });
    }

    // Keyboard controls
    document.addEventListener('keydown', (event) => {
      switch(event.code) {
        case 'Space':
          event.preventDefault();
          isAnimating = !isAnimating;
          if (playPauseBtn) {
            playPauseBtn.textContent = isAnimating ? 'Pause' : 'Play';
          }
          break;
        case 'KeyR':
          if (camera && controls) {
            camera.position.set(0, 0, amount * 1.8);
            controls.target.set(0, 0, 0);
            controls.update();
          }
          break;
        case 'KeyW':
          wireframeMode = !wireframeMode;
          if (mesh && mesh.material) {
            (mesh.material as THREE.MeshBasicMaterial).wireframe = wireframeMode;
          }
          if (wireframeBtn) {
            wireframeBtn.textContent = wireframeMode ? 'Solid' : 'Wireframe';
          }
          break;
      }
    });

    // Window resize
    window.addEventListener('resize', () => {
      const container = document.getElementById('threejs-container');
      if (container && camera && renderer) {
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
      }
    });
  }

  // Initialize when DOM is loaded
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initThreeJS);
  } else {
    initThreeJS();
  }
</script>

<style>
  .loading-container {
    @apply flex flex-col items-center justify-center h-full;
  }

  .loading-spinner {
    @apply w-8 h-8 border-2 border-primary/20 border-t-primary rounded-full animate-spin;
  }

  #threejs-container {
    position: relative;
  }

  #threejs-container canvas {
    display: block;
  }
</style>